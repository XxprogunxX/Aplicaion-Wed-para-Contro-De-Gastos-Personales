[33mcommit 5911196a8a9d51dbb7f418320dceebd650096bc5[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mfeatures/Comunicaci√≥n-as√≠ncrona-accesible[m[33m, [m[1;31morigin/features/Comunicaci√≥n-as√≠ncrona-accesible[m[33m)[m
Author: Oscar <oscar73981@gmail.com>
Date:   Thu Feb 19 20:57:37 2026 -0600

    avance de comunicaci√≥n as√≠ncrona-2

[1mdiff --git a/backend/src/controllers/gastosController.js b/backend/src/controllers/gastosController.js[m
[1mindex 5957d63..e7c39d4 100644[m
[1m--- a/backend/src/controllers/gastosController.js[m
[1m+++ b/backend/src/controllers/gastosController.js[m
[36m@@ -63,7 +63,7 @@[m [masync function create(req, res, next) {[m
     if (!descripcion || !monto || !categoria) {[m
       return res.status(400).json({[m
         error: true,[m
[31m-        message: "Error",[m
[32m+[m[32m        message: "Datos incompletos. Se requieren descripci√≥n, monto y categor√≠a.",[m
         status: 400[m
       })[m
     }[m
[36m@@ -80,7 +80,7 @@[m [masync function create(req, res, next) {[m
 [m
     res.status(201).json({[m
       error: false,[m
[31m-      message: "Exito",[m
[32m+[m[32m      message: "Gasto creado correctamente",[m
       data: nuevoGasto[m
     })[m
   } catch (err) {[m
[1mdiff --git a/backend/src/index.js b/backend/src/index.js[m
[1mindex cfccdbe..960e46f 100644[m
[1m--- a/backend/src/index.js[m
[1m+++ b/backend/src/index.js[m
[36m@@ -13,7 +13,7 @@[m [mconst authMiddleware = require('./middleware/auth')[m
 // Rutas[m
 const gastosRoutes = require('./routes/routes')[m
 [m
[31m-const PORT = process.env.PORT || 3003[m
[32m+[m[32mconst PORT = process.env.PORT || 3000[m
 [m
 // Configuraci√≥n[m
 app.use([m
[1mdiff --git a/docs/Arquitectura-API-estados-y-accesibilidad.md b/docs/Arquitectura-API-estados-y-accesibilidad.md[m
[1mnew file mode 100644[m
[1mindex 0000000..be4772d[m
[1m--- /dev/null[m
[1m+++ b/docs/Arquitectura-API-estados-y-accesibilidad.md[m
[36m@@ -0,0 +1,97 @@[m
[32m+[m[32m# Arquitectura de la API, Estados y Accesibilidad[m
[32m+[m
[32m+[m[32m## 1. Flujo general de consumo de la API[m
[32m+[m
[32m+[m[32mEl frontend consume la API REST del backend a trav√©s de un cliente centralizado (`frontend/src/lib/api.ts`) que usa Axios. Todas las llamadas pasan por el mismo flujo.[m
[32m+[m
[32m+[m[32m**Inicio.** El usuario o la p√°gina dispara una acci√≥n que requiere datos del servidor (por ejemplo: listar gastos, crear gasto, login).[m
[32m+[m
[32m+[m[32m**Request.** El cliente API construye la petici√≥n con la URL base (`NEXT_PUBLIC_API_URL`), headers `Content-Type: application/json` y, si existe token en `localStorage`, el header `Authorization: Bearer <token>`. No se hacen llamadas directas a `fetch` o Axios desde componentes; siempre se usa el cliente `api` o un hook que lo encapsule.[m
[32m+[m
[32m+[m[32m**Llamada as√≠ncrona.** La capa de UI no llama a `api` directamente en la mayor√≠a de los casos. Se usa el hook `useApi<T>()` (`frontend/src/hooks/useApi.ts`), que expone `execute(apiCall)`. El componente pasa una funci√≥n que devuelve la promesa de la llamada (por ejemplo `() => api.getGastos()`). El hook pone el estado en loading, ejecuta la promesa y actualiza data o error seg√∫n el resultado.[m
[32m+[m
[32m+[m[32m**Respuesta correcta.** Si el servidor responde con 2xx, el interceptor de Axios devuelve la respuesta tal cual. El hook guarda los datos en `state.data`, pone `loading: false` y `error: null`. El componente puede leer `data` y mostrarla (estado success impl√≠cito).[m
[32m+[m
[32m+[m[32m**Respuesta de error.** Si el servidor responde con 4xx o 5xx, el interceptor de respuesta convierte el error en un objeto con forma `ApiError`: `{ error: true, message: string, status: number }`. El mensaje se toma de `response.data.message` si existe; si no, se usa un texto por defecto. Si no hay respuesta (error de red), se lanza un ApiError con mensaje de conexi√≥n y status 0. El hook guarda ese objeto en `state.error`, pone `loading: false` y `data: null`, y opcionalmente re-lanza el error para que el componente pueda reaccionar.[m
[32m+[m
[32m+[m[32m**UI.** El componente que usa `useApi` debe comprobar `loading`, `error` y `data` para decidir qu√© mostrar: un loader mientras carga, un mensaje o componente de error si `error` no es null, o el contenido con `data` en caso de √©xito. As√≠ se cubren los tres estados globales (loading, error, success) de forma consistente.[m
[32m+[m
[32m+[m[32m## 2. Estados globales: loading, error, success[m
[32m+[m
[32m+[m[32mLos estados que debe manejar la UI al consumir la API son tres. Se modelan en el hook `useApi` y se reflejan en la interfaz.[m
[32m+[m
[32m+[m[32m**Loading.** Indica que hay una petici√≥n en curso. En `useApi` se activa al llamar a `execute` y se desactiva cuando la promesa se resuelve o se rechaza. El componente debe mostrar un indicador de carga accesible (por ejemplo el componente `Loading`) y, si aplica, deshabilitar botones o formularios para evitar env√≠os duplicados. No se considera un estado "global" de aplicaci√≥n tipo Redux: cada uso de `useApi` tiene su propio loading; si se necesita un loading global (por ejemplo barra superior), se puede centralizar m√°s adelante con contexto o estado global.[m
[32m+[m
[32m+[m[32m**Error.** Indica que la √∫ltima petici√≥n fall√≥. En `useApi` se guarda en `state.error` con tipo `ApiError` (`error: true`, `message`, `status`). El componente debe mostrar el mensaje al usuario (por ejemplo con el componente `Alert` type="error") y ofrecer una acci√≥n de recuperaci√≥n cuando tenga sentido (reintentar, volver, cerrar). El hook expone `reset()` para limpiar error (y data) sin hacer una nueva petici√≥n.[m
[32m+[m
[32m+[m[32m**Success.** No hay un booleano expl√≠cito "success". Se considera √©xito cuando `loading === false` y `error === null` y, en muchos casos, `data !== null`. El componente muestra entonces el contenido basado en `data`. Para acciones que no devuelven datos (por ejemplo eliminar), success se interpreta como "no loading y no error" y la UI puede mostrar un mensaje breve de confirmaci√≥n o actualizar la lista.[m
[32m+[m
[32m+[m[32mCriterio de uso: en cualquier pantalla que llame a la API, comprobar siempre los tres casos (loading, error, data/success) y asegurar que en cada momento solo se muestre uno de ellos de forma clara (evitar mostrar datos y error a la vez, o loader y error a la vez).[m
[32m+[m
[32m+[m[32m## 3. Criterios de accesibilidad en carga y errores[m
[32m+[m
[32m+[m[32m**Carga (loaders).** El indicador de carga debe ser anunciado por lectores de pantalla. En este proyecto el componente `Loading` usa un elemento con `role="status"` y `aria-label` con el texto de carga (por defecto "Cargando..."). El texto visible y el aria-label deben coincidir y ser descriptivos (por ejemplo "Cargando gastos..."). Evitar que el loader sea solo decorativo: debe tener `role="status"` o `aria-live="polite"` y un nombre accesible. No cubrir toda la pantalla con un overlay sin anunciar el estado; si se usa overlay, incluir en √©l el mismo `role="status"` y aria-label. Durante la carga, el foco no debe perderse: si se deshabilita un bot√≥n, el foco puede moverse al loader o mantenerse en un elemento que siga siendo focusable.[m
[32m+[m
[32m+[m[32m**Errores.** Los mensajes de error deben presentarse como alertas. Usar `role="alert"` para que se anuncien de inmediato (o el componente `Alert` que ya lo usa). El mensaje debe ser claro y accionable para el usuario, no t√©cnico. Si el error est√° asociado a un campo de formulario, usar `aria-describedby` apuntando al id del mensaje de error y `aria-invalid="true"` en el campo. En p√°ginas de error completas (404, 500), el proyecto ya incluye un bloque con `aria-live="assertive"` y texto para lectores de pantalla: en `not-found.tsx` ("Error 404. P√°gina no encontrada.") y en `error-500.tsx` ("Error 500. Error interno del servidor"). Cualquier bot√≥n de "Reintentar" o "Volver" debe ser focusable y accionable por teclado; en la p√°gina 500 se mantiene un manejo de foco para facilitar la navegaci√≥n.[m
[32m+[m
[32m+[m[32m**Resumen.** Loaders: `role="status"` y aria-label descriptivo, texto visible coherente. Errores: `role="alert"`, mensaje claro, relaci√≥n con campos cuando aplique. P√°ginas de error: anuncio con aria-live y navegaci√≥n por teclado clara.[m
[32m+[m
[32m+[m[32m## 4. Revisi√≥n de arquitectura entre frontend y backend[m
[32m+[m
[32m+[m[32m**Backend.** Servidor Express en `backend/`. En el estado actual del proyecto expone el endpoint de salud `GET /health` y las rutas de gastos bajo `GET/POST/PUT/DELETE /api/gastos` (y subrutas `/:id`), protegidas por `authMiddleware`. Otras rutas (auth, categor√≠as, presupuestos, reportes) est√°n previstas en el cliente del frontend pero a√∫n no est√°n montadas en el backend. Usa middlewares de body (`express.json()`), autenticaci√≥n (`authMiddleware` en rutas protegidas), manejo de rutas no encontradas (`notFoundHandler`) y manejo global de errores (`errorHandler`). Los controladores devuelven JSON; en error siempre con la forma `{ error: true, message, status }`. Algunos controladores en √©xito env√≠an `{ error: false, message, data }`; otros env√≠an directamente el recurso. Para una arquitectura clara, se recomienda unificar: respuestas de error siempre `{ error, message, status }`; respuestas de √©xito o bien solo el payload (y el cliente asume 2xx) o bien un formato √∫nico como `{ data }` o `{ success, data, message }`.[m
[32m+[m
[32m+[m[32m**Frontend.** Aplicaci√≥n Next.js en `frontend/` con App Router. La capa de datos se compone de: (1) cliente API (`lib/api.ts`), instancia √∫nica de Axios con baseURL, interceptor de token e interceptor de errores que normaliza a `ApiError`; (2) hook `useApi` que gestiona loading, error y data por llamada; (3) tipos en `types/index.ts` alineados con la API (Gasto, Categoria, ApiError, etc.). Las p√°ginas y componentes no deben crear nuevas instancias de Axios ni llamar a `fetch` directamente; deben usar `api` y, preferiblemente, `useApi` para tener loading/error/success de forma uniforme.[m
[32m+[m
[32m+[m[32m**Contrato.** La API es REST; el cliente espera JSON. Los c√≥digos HTTP indican el resultado (2xx √©xito, 4xx error de cliente, 5xx error de servidor). El frontend espera que en error el cuerpo tenga al menos `message` (string) y opcionalmente `status`. El backend ya env√≠a ese formato en los middlewares y en los controladores que devuelven error; conviene que todos los controladores que lancen error usen `next(err)` o respondan con el mismo esquema para que el interceptor del frontend siempre reciba un mensaje consistente.[m
[32m+[m
[32m+[m[32m**Despliegue.** Backend y frontend son independientes: el frontend usa `NEXT_PUBLIC_API_URL` para saber la base URL del backend. En el c√≥digo actual el backend usa por defecto el puerto 3001 (`backend/src/index.js`) y el frontend en desarrollo corre en el puerto 3001 (`frontend/package.json`: `next dev -p 3001`); el fallback de la URL de la API en `frontend/src/lib/api.ts` es `http://localhost:3000`. Para desarrollo local sin conflicto de puertos, ejecutar el backend en 3000 (por ejemplo `PORT=3000 node backend/src/index.js` o configurar en `.env`) y el frontend en 3001, o ejecutar el backend en 3001 y el frontend en otro puerto y definir `NEXT_PUBLIC_API_URL=http://localhost:3001`. En producci√≥n se configura la URL del API en el frontend. No hay proxy obligatorio; CORS debe estar permitido en el backend para el origen del frontend.[m
[32m+[m
[32m+[m[32m## 5. Mensajes de error consistentes[m
[32m+[m
[32m+[m[32m**Backend.** Todos los errores que llegan al usuario deben tener el mismo formato JSON: `{ error: true, message: string, status: number }`. El `message` debe ser breve, en espa√±ol y orientado al usuario (no stack traces ni detalles internos). Ejemplos ya usados en el proyecto: "Ruta no encontrada" (404), "Gasto no encontrado" (404), "Datos incompletos" (400), "Error interno del servidor" (500). Los controladores que devuelven error deben usar ese mismo esquema; los que delegan en el middleware con `next(err)` dependen de que el error tenga `status` y `message` para que el `errorHandler` los use. Se recomienda definir constantes o un peque√±o m√≥dulo de mensajes (por c√≥digo HTTP o por tipo de error) para reutilizar los mismos textos en todos los controladores.[m
[32m+[m
[32m+[m[32m**Frontend.** El interceptor de Axios ya normaliza a `ApiError`: `message` viene de `response.data.message` o de mensajes por defecto ("Error desconocido", "Error de conexi√≥n. Verifica tu conexi√≥n a internet.", "Error interno de la aplicaci√≥n."). Los componentes que muestran error deben usar siempre `error.message` para el texto en pantalla, de modo que el usuario vea el mismo mensaje que envi√≥ el backend o uno de estos fallbacks. No mostrar `error.status` al usuario salvo en contextos de depuraci√≥n; para accesibilidad basta con el mensaje en `role="alert"`. Si en el futuro el backend env√≠a c√≥digos de error (por ejemplo `code: "VALIDATION_ERROR"`), el frontend puede mapear c√≥digos a mensajes locales para mantener consistencia y permitir traducci√≥n.[m
[32m+[m
[32m+[m[32m**Resumen.** Backend: un solo formato de error, mensajes en espa√±ol y no t√©cnicos. Frontend: mostrar solo `error.message`, mismo criterio para todos los componentes (Alert, p√°ginas de error, formularios).[m
[32m+[m
[32m+[m[32m## 6. Entregables del Tech Lead[m
[32m+[m
[32m+[m[32m### 6.1 Diagrama de flujo de la comunicaci√≥n as√≠ncrona[m
[32m+[m
[32m+[m[32mIncluido en la secci√≥n 2 de este documento. El diagrama en ASCII describe el flujo desde el componente hasta el backend y de vuelta, pasando por el hook `useApi`, el cliente API, los interceptores, el middleware y controladores del backend, y la actualizaci√≥n de estados (loading, data, error) en el frontend. Puede trasladarse a Mermaid o a otra herramienta si se prefiere un diagrama gr√°fico; la secuencia descrita se mantiene.[m
[32m+[m
[32m+[m[32m### 6.2 Documentaci√≥n de arquitectura[m
[32m+[m
[32m+[m[32mLa secci√≥n 5 de este documento constituye la documentaci√≥n de arquitectura entre frontend y backend: responsabilidades del backend (Express, rutas, middlewares, formato de error), del frontend (Next.js, cliente API, hook useApi, tipos), contrato de la API (REST, JSON, formato de error) y consideraciones de despliegue (variables de entorno, CORS). Para m√°s detalle por m√≥dulo, se puede ampliar con descripci√≥n de cada ruta en `backend/src/routes` y de cada m√©todo del cliente en `frontend/src/lib/api.ts`.[m
[32m+[m
[32m+[m[32m### 6.3 Normas para loaders y errores accesibles[m
[32m+[m
[32m+[m[32mA continuaci√≥n se resumen las normas que debe cumplir el proyecto para loaders y errores accesibles.[m
[32m+[m
[32m+[m[32m**Loaders (indicadores de carga).**[m
[32m+[m
[32m+[m[32m- Todo indicador de carga debe tener `role="status"` para que los lectores de pantalla lo anuncien.[m
[32m+[m[32m- Proporcionar un `aria-label` descriptivo (por ejemplo "Cargando gastos", "Enviando formulario"). El texto visible del loader y el aria-label deben ser el mismo o equivalentes.[m
[32m+[m[32m- No usar solo un spinner visual sin nombre accesible; si el loader es un √≠cono, envolverlo o asociarlo a un elemento con `role="status"` y aria-label.[m
[32m+[m[32m- En formularios o botones que disparan la petici√≥n, mientras `loading` sea true deshabilitar el bot√≥n de env√≠o y, si se desea, mostrar el loader junto al bot√≥n o en la zona de contenido que se est√° cargando.[m
[32m+[m[32m- Evitar overlays de carga que bloqueen toda la pantalla sin anunciar el estado; si se usan, incluir en el overlay el mismo `role="status"` y aria-label.[m
[32m+[m
[32m+[m[32m**Errores (mensajes y pantallas).**[m
[32m+[m
[32m+[m[32m- Todo mensaje de error mostrado al usuario debe estar en un contenedor con `role="alert"` para que se anuncien de inmediato (el componente `Alert` del proyecto ya lo cumple).[m
[32m+[m[32m- El texto del error debe ser el `message` devuelto por la API o el fallback del cliente; ha de ser claro y accionable, no t√©cnico.[m
[32m+[m[32m- En formularios, si el error es por campo: asociar el mensaje al input con `aria-describedby` y marcar el campo con `aria-invalid="true"` cuando haya error de validaci√≥n.[m
[32m+[m[32m- En p√°ginas de error completas (404, 500): incluir un elemento con `aria-live="assertive"` (o "polite") y `aria-atomic="true"` que resuma el error para lectores de pantalla (por ejemplo "Error 404. P√°gina no encontrada").[m
[32m+[m[32m- Los botones de recuperaci√≥n (Reintentar, Volver al inicio) deben ser focusable y activables por teclado; en p√°ginas de error cr√≠ticas se recomienda mantener el foco en un elemento l√≥gico (t√≠tulo o primer enlace) al montar la p√°gina.[m
[32m+[m
[32m+[m[32m**Consistencia.**[m
[32m+[m
[32m+[m[32m- Usar el componente `Loading` para indicadores de carga y el componente `Alert` (type="error" o el que corresponda) para errores in-page, de modo que todos cumplan las normas anteriores por defecto.[m
[32m+[m[32m- Revisar que en ninguna pantalla se muestren a la vez loader y mensaje de error; la transici√≥n debe ser loading ‚Üí success (datos) o loading ‚Üí error (mensaje).[m
[32m+[m
[32m+[m[32mCon estas normas se asegura que la carga y los errores sean accesibles y coherentes en todo el proyecto.[m
[32m+[m
[32m+[m[32m## 7. Adaptaci√≥n al proyecto actual[m
[32m+[m
[32m+[m[32mEste documento est√° alineado con el c√≥digo del repositorio: cliente en `frontend/src/lib/api.ts`, hook en `frontend/src/hooks/useApi.ts`, tipos en `frontend/src/types/index.ts`, componente `Loading` en `frontend/src/components/ui/Loading.tsx`, componente `Alert` en `frontend/src/components/ui/Alert.tsx`, backend en `backend/src/index.js`, controlador de gastos en `backend/src/controllers/gastosController.js`, middlewares de error en `backend/src/middleware/errorHandler.js` y `notFoundHandler.js`, y p√°ginas de error en `frontend/src/app/not-found.tsx` y `frontend/src/app/pantalla-de-errores/error-500.tsx`. En el estado actual, el backend solo monta las rutas `/api/gastos` y `/health`; el cliente API ya define m√©todos para auth, categor√≠as, presupuestos y reportes para cuando esas rutas existan. Las respuestas de √©xito del controlador de gastos tienen la forma `{ error: false, message, data }`; si el cliente devuelve `response.data` sin extraer `data`, los componentes deben usar `data.data` para obtener el array de gastos (o se puede normalizar en el cliente). Por defecto el backend usa el puerto 3001 y el frontend en desarrollo tambi√©n (Next.js en 3001); la URL base de la API en el frontend es `NEXT_PUBLIC_API_URL` con fallback `http://localhost:3000`. Para evitar conflicto de puertos, conviene ejecutar el backend en 3000 (`PORT=3000`) y el frontend en 3001, o asignar otro puerto al frontend y configurar `NEXT_PUBLIC_API_URL` al puerto donde corre el backend.</content>[m
[32m+[m[32m<parameter name="filePath">c:\Users\oscar\Desktop\Aplicaion-Wed-para-Contro-De-Gastos-Personales\docs\Arquitectura-API-estados-y-accesibilidad.md[m
\ No newline at end of file[m
[1mdiff --git a/docs/Como-Probar-el-Backend.md b/docs/Como-Probar-el-Backend.md[m
[1mnew file mode 100644[m
[1mindex 0000000..3259a0e[m
[1m--- /dev/null[m
[1m+++ b/docs/Como-Probar-el-Backend.md[m
[36m@@ -0,0 +1,293 @@[m
[32m+[m[32m# C√≥mo Probar el Backend[m
[32m+[m
[32m+[m[32mEste documento explica c√≥mo probar el backend de la aplicaci√≥n de control de gastos personales. El backend es una API REST construida con Express.js que maneja operaciones CRUD para gastos, adem√°s de un endpoint de salud.[m
[32m+[m
[32m+[m[32m## Prerrequisitos[m
[32m+[m
[32m+[m[32m- **Node.js** versi√≥n 16 o superior.[m
[32m+[m[32m- **npm** (viene con Node.js).[m
[32m+[m[32m- **Postman** o **curl** para hacer requests HTTP (opcional, pero recomendado para pruebas manuales).[m
[32m+[m[32m- **Git** para clonar el repositorio (si no lo tienes localmente).[m
[32m+[m
[32m+[m[32m## Instalaci√≥n[m
[32m+[m
[32m+[m[32m1. Clona el repositorio si no lo tienes:[m
[32m+[m[32m   ```[m
[32m+[m[32m   git clon